// @ts-check

const pLimit = require("p-limit").default;
const path = require("path");
const { readJsonFile, writeJsonFile, getFileInfo } = require("./fileHandler");
const { translateBatch } = require("./geminiTranslator");

/**
 * Control global de l√≠mites de velocidad
 */
let rateLimiter = {
  requests: /** @type {number[]} */ ([]),
  limits: /** @type {any} */ (null),
  tier: "free_tier",
  model: "gemini-2.0-flash-lite",
};

/**
 * Configuraci√≥n por defecto para el procesamiento por lotes
 */
const DEFAULT_CONFIG = {
  batchSize: 10, // N√∫mero de entradas por lote
  concurrencyLimit: 3, // N√∫mero m√°ximo de lotes procesados simult√°neamente
  maxRetries: 3, // N√∫mero m√°ximo de reintentos por lote fallido
  retryDelay: 2000, // Delay base en ms entre reintentos (con backoff exponencial)
  outputFile: "output.json", // Archivo de salida por defecto
  skipTranslated: true, // Si debe omitir entradas ya traducidas
  enableKeyFiltering: true, // Si debe filtrar claves que no necesitan traducci√≥n
  tier: "free_tier", // Tier de la API (free_tier, tier_1, tier_2, tier_3)
  model: "gemini-2.0-flash-lite", // Modelo de Gemini a usar
  respectRateLimits: true, // Si debe respetar los l√≠mites de velocidad
  rateLimitsFile: "rate-limits.json", // Archivo con l√≠mites de velocidad
};

/**
 * Carga los l√≠mites de velocidad desde el archivo rate-limits.json
 * @param {string} rateLimitsFile - Ruta al archivo de l√≠mites
 * @returns {Promise<Object>} - L√≠mites de velocidad
 */
async function loadRateLimits(rateLimitsFile = "rate-limits.json") {
  try {
    const filePath = path.resolve(rateLimitsFile);
    const rateLimits = await readJsonFile(filePath);
    console.log(`üìä L√≠mites de velocidad cargados desde: ${filePath}`);
    return rateLimits;
  } catch (error) {
    console.warn(
      `‚ö†Ô∏è No se pudo cargar el archivo de l√≠mites: ${rateLimitsFile}`
    );
    console.warn(`‚ö†Ô∏è Usando l√≠mites por defecto para free_tier`);

    // L√≠mites por defecto si no se puede cargar el archivo
    return {
      free_tier: {
        "gemini-2.0-flash-lite": {
          rpm: 30,
          tpm: 1000000,
          rpd: 200,
        },
      },
    };
  }
}

/**
 * Inicializa el controlador de l√≠mites de velocidad
 * @param {string} tier - Tier de la API (free_tier, tier_1, tier_2, tier_3)
 * @param {string} model - Modelo de Gemini
 * @param {string} rateLimitsFile - Archivo de l√≠mites
 */
async function initializeRateLimiter(tier, model, rateLimitsFile) {
  try {
    const rateLimits = /** @type {any} */ (
      await loadRateLimits(rateLimitsFile)
    );

    // Verificar que el tier existe
    if (!rateLimits[tier]) {
      throw new Error(`Tier "${tier}" no encontrado en el archivo de l√≠mites`);
    }

    // Verificar que el modelo existe para ese tier
    if (!rateLimits[tier][model]) {
      // Buscar un modelo compatible
      const availableModels = Object.keys(rateLimits[tier]);
      console.warn(`‚ö†Ô∏è Modelo "${model}" no encontrado en tier "${tier}"`);
      console.warn(`‚ö†Ô∏è Modelos disponibles: ${availableModels.join(", ")}`);

      // Usar el primer modelo disponible como fallback
      if (availableModels.length > 0) {
        const fallbackModel = availableModels[0];
        console.warn(`‚ö†Ô∏è Usando modelo fallback: ${fallbackModel}`);
        model = fallbackModel;
      } else {
        throw new Error(`No hay modelos disponibles en tier "${tier}"`);
      }
    }

    rateLimiter.limits = rateLimits[tier][model];
    rateLimiter.tier = tier;
    rateLimiter.model = model;
    rateLimiter.requests = [];

    console.log(`üö¶ Rate limiter inicializado:`);
    console.log(`   üìä Tier: ${tier}`);
    console.log(`   ü§ñ Modelo: ${model}`);
    console.log(`   üìà RPM: ${rateLimiter.limits?.rpm}`);
    console.log(`   üî¢ TPM: ${rateLimiter.limits?.tpm}`);
    if (rateLimiter.limits?.rpd) {
      console.log(`   üìÖ RPD: ${rateLimiter.limits.rpd}`);
    }

    return rateLimiter.limits;
  } catch (/** @type {any} */ error) {
    console.error(`‚ùå Error inicializando rate limiter: ${error.message}`);
    throw error;
  }
}

/**
 * Verifica si se puede hacer una nueva petici√≥n respetando los l√≠mites RPM
 * @returns {boolean} - true si se puede hacer la petici√≥n
 */
function canMakeRequest() {
  if (!rateLimiter.limits || !rateLimiter.limits?.rpm) {
    return true; // Si no hay l√≠mites configurados, permitir
  }

  const now = Date.now();
  const oneMinuteAgo = now - 60000; // 60 segundos en ms

  // Filtrar peticiones del √∫ltimo minuto
  rateLimiter.requests = rateLimiter.requests.filter(
    (timestamp) => timestamp > oneMinuteAgo
  );

  // Verificar si podemos hacer otra petici√≥n
  return rateLimiter.requests.length < rateLimiter.limits.rpm;
}

/**
 * Registra una nueva petici√≥n en el contador
 */
function recordRequest() {
  if (rateLimiter.limits) {
    rateLimiter.requests.push(Date.now());
  }
}

/**
 * Calcula el tiempo de espera necesario para respetar los l√≠mites RPM
 * @returns {number} - Tiempo de espera en milisegundos
 */
function calculateWaitTime() {
  if (!rateLimiter.limits || !rateLimiter.limits?.rpm) {
    return 0;
  }

  const now = Date.now();
  const oneMinuteAgo = now - 60000;

  // Filtrar peticiones del √∫ltimo minuto
  rateLimiter.requests = rateLimiter.requests.filter(
    (timestamp) => timestamp > oneMinuteAgo
  );

  if (rateLimiter.requests.length === 0) {
    return 0; // No hay peticiones recientes
  }

  if (rateLimiter.requests.length < rateLimiter.limits.rpm) {
    return 0; // A√∫n podemos hacer m√°s peticiones
  }

  // Calcular cu√°ndo expira la petici√≥n m√°s antigua
  const oldestRequest = Math.min(...rateLimiter.requests);
  const waitTime = oldestRequest + 60000 - now + 100; // +100ms de buffer

  return Math.max(0, waitTime);
}

/**
 * Espera el tiempo necesario para respetar los l√≠mites de velocidad
 * @returns {Promise<void>}
 */
async function waitForRateLimit() {
  const waitTime = calculateWaitTime();

  if (waitTime > 0) {
    const seconds = (waitTime / 1000).toFixed(1);
    console.log(
      `üö¶ Esperando ${seconds}s para respetar l√≠mite de ${rateLimiter.limits?.rpm} RPM...`
    );
    await new Promise((resolve) => setTimeout(resolve, waitTime));
  }
}

/**
 * Obtiene informaci√≥n actual del rate limiter
 * @returns {Object} - Estado actual del rate limiter
 */
function getRateLimiterStatus() {
  if (!rateLimiter.limits) {
    return {
      initialized: false,
      message: "Rate limiter no inicializado",
    };
  }

  const now = Date.now();
  const oneMinuteAgo = now - 60000;
  const recentRequests = /** @type {number[]} */ (
    rateLimiter.requests.filter((timestamp) => timestamp > oneMinuteAgo)
  );

  return {
    initialized: true,
    tier: rateLimiter.tier,
    model: rateLimiter.model,
    limits: rateLimiter.limits,
    currentRequests: recentRequests.length,
    remainingRequests: Math.max(
      0,
      rateLimiter.limits?.rpm - recentRequests.length
    ),
    canMakeRequest: canMakeRequest(),
    nextAvailableIn: calculateWaitTime(),
  };
}

/**
 * Verifica si un valor est√° vac√≠o o necesita traducci√≥n
 * @param {any} value - Valor a verificar
 * @returns {boolean} - true si el valor necesita traducci√≥n
 */
function needsTranslation(value) {
  // Considerar como "necesita traducci√≥n" si el valor es:
  // - null, undefined, vac√≠o, o solo espacios en blanco
  return (
    value === null ||
    value === undefined ||
    value === "" ||
    (typeof value === "string" && value.trim() === "")
  );
}

/**
 * Verifica si una clave debe ser excluida del procesamiento de traducci√≥n
 * @param {string} key - Clave a verificar
 * @returns {boolean} - true si la clave debe ser excluida
 */
function shouldExcludeKey(key) {
  // 1. Solo n√∫meros (a√±os, c√≥digos, etc.)
  if (/^\d+$/.test(key)) {
    return true;
  }

  // 2. N√∫meros con unidades de medida, rangos, o caracteres especiales
  if (/\d+.*[-\/><].*\d*|\d+.*\s*(kg|lb|PCT|%|\+)\s*$/i.test(key)) {
    return true;
  }

  // 3. A√±os con formato de temporada (1998/99, 2023/24, etc.)
  if (/^\d{4}\/\d{2}$/.test(key)) {
    return true;
  }

  // 4. Palabras que ya contienen caracteres del espa√±ol (acentos, √±)
  if (/[√°√©√≠√≥√∫√Å√â√ç√ì√ö√±√ë]/.test(key)) {
    return true;
  }

  // 5. Claves que inician con prefijos espec√≠ficos
  if (/^(_Daily - |YTD_|DC_.*_YTD|.*_YTD_)/i.test(key)) {
    return true;
  }

  // 6. Patrones adicionales identificados:

  // Fechas y per√≠odos espec√≠ficos
  if (
    /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)['']?\d{2}$/.test(key)
  ) {
    return true; // Aug'24, Jan'25, etc.
  }

  // C√≥digos de pa√≠ses (ISO)
  if (/^[A-Z]{2,3}$/.test(key)) {
    return true; // USA, MEX, CAN, etc.
  }

  // S√≠mbolos de monedas
  if (/^[A-Z]{3}\s*(Dollar|Peso|Euro|Yen)$/i.test(key)) {
    return true;
  }

  // C√≥digos TIF y similares
  if (/TIF\s*\d+/i.test(key)) {
    return true;
  }

  // Nombres de empresas mexicanas (contienen "S.A.", "de C.V.", etc.)
  if (/(S\.?\s*A\.?|de\s+C\.?\s*V\.?|A\.?\s*R\.?\s*I\.?\s*C)/i.test(key)) {
    return true;
  }

  // Nombres de lugares mexicanos espec√≠ficos ya en espa√±ol
  const mexicanPlaces = [
    "Atizap√°n",
    "Canc√∫n",
    "Cuautitl√°n",
    "M√©rida",
    "Le√≥n",
    "Culiac√°n",
    "Obreg√≥n",
    "Quer√©taro",
    "G√≥mez Palacios",
    "Tampico",
    "Ciudad de M√©xico",
  ];
  if (mexicanPlaces.some((place) => key.includes(place))) {
    return true;
  }

  // T√©rminos financieros espec√≠ficos que son m√°s c√≥digos que palabras
  if (/^(FRED|FHFA|CPI|PPI|GDP|USD|CAD|EUR|GBP|JPY)$/i.test(key)) {
    return true;
  }

  // C√≥digos de futuros y commodities
  if (/(Futures?|Daily|Weekly|Monthly|Quarterly).*-\s*(Nearby|H)$/i.test(key)) {
    return true;
  }

  // Porcentajes espec√≠ficos
  if (/^\d+(\.\d+)?\s*-\s*\d+(\.\d+)?\s*PCT$/i.test(key)) {
    return true;
  }

  return false;
}

/**
 * Filtra las entradas que necesitan traducci√≥n
 * @param {Object} jsonData - Datos JSON originales
 * @param {boolean} skipTranslated - Si debe omitir entradas ya traducidas
 * @param {boolean} enableKeyFiltering - Si debe filtrar claves autom√°ticamente
 * @returns {any} - Objeto con entradas filtradas, estad√≠sticas y orden original
 */
function filterEntriesForTranslation(
  jsonData,
  skipTranslated = true,
  enableKeyFiltering = true
) {
  console.log(
    `üîç Analizando entradas para determinar cu√°les necesitan traducci√≥n...`
  );

  const allEntries = Object.entries(jsonData);
  /**@type {any} */
  const toTranslate = {};
  /**@type {any} */
  const alreadyTranslated = {};
  /**@type {any} */
  const excludedByKey = {};
  const originalKeys = Object.keys(jsonData); // Preservar orden original

  allEntries.forEach(([key, value]) => {
    // Primero verificar si la clave debe ser excluida por patr√≥n
    if (enableKeyFiltering && shouldExcludeKey(key)) {
      excludedByKey[key] = value;
      return;
    }

    // Luego verificar si ya est√° traducida
    if (skipTranslated && !needsTranslation(value)) {
      // Esta entrada ya est√° traducida, la guardamos para el resultado final
      alreadyTranslated[key] = value;
    } else {
      // Esta entrada necesita traducci√≥n
      toTranslate[key] = value;
    }
  });

  const stats = {
    total: allEntries.length,
    needsTranslation: Object.keys(toTranslate).length,
    alreadyTranslated: Object.keys(alreadyTranslated).length,
    excludedByKey: Object.keys(excludedByKey).length,
    skippedDueToTranslation: Object.keys(alreadyTranslated).length,
  };

  console.log(`üìä An√°lisis completado:`);
  console.log(`   üìù Total de entradas: ${stats.total}`);
  console.log(`   üîÑ Necesitan traducci√≥n: ${stats.needsTranslation}`);
  console.log(`   ‚úÖ Ya traducidas (se omitir√°n): ${stats.alreadyTranslated}`);
  console.log(`   üö´ Excluidas por patr√≥n de clave: ${stats.excludedByKey}`);
  console.log(
    `   üìà Eficiencia: ${(
      ((stats.excludedByKey + stats.alreadyTranslated) / stats.total) *
      100
    ).toFixed(1)}% de entradas no requieren procesamiento`
  );

  if (stats.needsTranslation === 0) {
    console.log(
      `üéâ ¬°Todas las entradas ya est√°n traducidas o fueron excluidas! No hay nada que procesar.`
    );
  }

  return {
    toTranslate,
    alreadyTranslated,
    excludedByKey, // Nuevo: claves excluidas por patr√≥n
    originalKeys, // Incluir el orden original
    stats,
  };
}

/**
 * Divide un objeto JSON en lotes m√°s peque√±os
 * @param {any} jsonData - Datos JSON a dividir (solo las que necesitan traducci√≥n)
 * @param {number} batchSize - Tama√±o de cada lote
 * @returns {Array<any>} - Array de objetos, cada uno es un lote
 */
function createBatches(jsonData, batchSize) {
  const entriesCount = Object.keys(jsonData).length;

  if (entriesCount === 0) {
    console.log(`‚ÑπÔ∏è  No hay entradas para procesar en lotes.`);
    return [];
  }

  console.log(
    `üî™ Dividiendo ${entriesCount} entradas en lotes de tama√±o ${batchSize}...`
  );

  const entries = Object.entries(jsonData);
  const batches = [];

  for (let i = 0; i < entries.length; i += batchSize) {
    const batchEntries = entries.slice(i, i + batchSize);
    const batch = Object.fromEntries(batchEntries);
    batches.push({
      id: Math.floor(i / batchSize) + 1,
      data: batch,
      entriesCount: batchEntries.length,
      startIndex: i,
      endIndex: Math.min(i + batchSize - 1, entries.length - 1),
    });
  }

  console.log(`‚úÖ ${batches.length} lotes creados`);
  return batches;
}

/**
 * Procesa un lote individual con reintentos
 * @param {any} batch - El lote a procesar
 * @param {number} maxRetries - N√∫mero m√°ximo de reintentos
 * @param {number} retryDelay - Delay base entre reintentos
 * @returns {Promise<Object>} - Resultado del procesamiento
 */
async function processBatchWithRetry(batch, maxRetries, retryDelay) {
  /**@type {any} */
  let lastError;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(
        `üîÑ Procesando lote ${batch.id} (intento ${attempt}/${maxRetries})...`
      );

      // Esperar para respetar l√≠mites de velocidad antes de hacer la petici√≥n
      if (rateLimiter.limits) {
        await waitForRateLimit();
        recordRequest();
      }

      const translatedData = await translateBatch(batch.data);

      console.log(`‚úÖ Lote ${batch.id} completado exitosamente`);
      return {
        success: true,
        batchId: batch.id,
        data: translatedData,
        attempts: attempt,
      };
    } catch (/**@type {any} */ error) {
      lastError = error;
      console.error(
        `‚ùå Error en lote ${batch.id}, intento ${attempt}: ${error.message}`
      );

      // Verificar si es un error fatal que debe detener todo el procesamiento
      if (error.shouldStop) {
        console.error(
          `üõë Error fatal en lote ${batch.id}: ${error.message} - Deteniendo reintentos`
        );
        return {
          success: false,
          batchId: batch.id,
          error: error.message,
          attempts: attempt,
          isFatal: true,
          shouldStopProcessing: true,
        };
      }

      if (attempt < maxRetries) {
        const delay = retryDelay * Math.pow(2, attempt - 1); // Backoff exponencial
        console.log(`‚è≥ Esperando ${delay}ms antes del siguiente intento...`);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  }

  // Si llegamos aqu√≠, todos los intentos fallaron
  console.error(`üíÄ Lote ${batch.id} fall√≥ despu√©s de ${maxRetries} intentos`);
  return {
    success: false,
    batchId: batch.id,
    error: lastError.message,
    attempts: maxRetries,
    isFatal: lastError.isFatal || false,
    shouldStopProcessing: lastError.shouldStop || false,
  };
}

/**
 * Procesa todos los lotes de forma concurrente con detecci√≥n de errores fatales
 * @param {Array<any>} batches - Array de lotes a procesar
 * @param {any} config - Configuraci√≥n del procesamiento
 * @returns {Promise<any>} - Resultados del procesamiento con informaci√≥n de parada
 */
async function processBatchesConcurrently(batches, config) {
  const { concurrencyLimit, maxRetries, retryDelay } = config;

  if (batches.length === 0) {
    console.log(`‚ÑπÔ∏è  No hay lotes para procesar.`);
    return {
      successful: [],
      failed: [],
      stoppedEarly: false,
      fatalError: null,
    };
  }

  console.log(
    `üöÄ Iniciando procesamiento concurrente de ${batches.length} lotes con l√≠mite de ${concurrencyLimit} lotes simult√°neos`
  );

  // Crear limitador de concurrencia
  const limit = pLimit(concurrencyLimit);

  /**
   * @type {any[]}
   */
  const successful = [];
  /**@type {any[]} */
  const failed = [];
  let stoppedEarly = false;
  let fatalError = null;
  let processedCount = 0;

  // Procesar lotes uno por uno para poder detectar errores fatales
  for (const batch of batches) {
    if (stoppedEarly) {
      // Si ya encontramos un error fatal, marcar los lotes restantes como no procesados
      failed.push({
        success: false,
        batchId: batch.id,
        error: "Procesamiento detenido por error fatal anterior",
        attempts: 0,
        skipped: true,
      });
      continue;
    }

    try {
      console.log(`üì¶ Procesando lote ${batch.id} de ${batches.length}...`);
      const result = await limit(() =>
        processBatchWithRetry(batch, maxRetries, retryDelay)
      );

      processedCount++;

      // @ts-ignore
      if (result.success) {
        successful.push(result);
        console.log(`‚úÖ Lote ${batch.id} completado exitosamente`);
      } else {
        failed.push(result);

        // Verificar si es un error fatal que debe detener el procesamiento
        // @ts-ignore
        if (result.shouldStopProcessing) {
          console.error(
            // @ts-ignore
            `üõë Error fatal detectado en lote ${batch.id}: ${result.error}`
          );
          console.error(
            `üõë Deteniendo procesamiento. Lotes procesados: ${processedCount}/${batches.length}`
          );
          stoppedEarly = true;
          // @ts-ignore
          fatalError = result.error;
          break;
        }

        // @ts-ignore
        console.error(`‚ùå Lote ${batch.id} fall√≥: ${result.error}`);
      }
    } catch (/**@type {any} */ error) {
      // Manejo de errores inesperados
      const errorResult = {
        success: false,
        batchId: batch.id,
        // @ts-ignore
        error: error.message || "Error desconocido",
        attempts: 0,
      };
      failed.push(errorResult);
      // @ts-ignore
      console.error(`üíÄ Error inesperado en lote ${batch.id}:`, error.message);
    }
  }

  if (stoppedEarly) {
    console.log(
      `‚ö†Ô∏è  Procesamiento detenido prematuramente debido a error fatal`
    );
    console.log(
      `üìä Lotes completados: ${successful.length}, Fallidos: ${
        failed.filter((f) => !f.skipped).length
      }, Omitidos: ${failed.filter((f) => f.skipped).length}`
    );
  } else {
    console.log(
      `‚úÖ Procesamiento completo: ${successful.length} exitosos, ${failed.length} fallidos`
    );
  }

  return { successful, failed, stoppedEarly, fatalError };
}

/**
 * Ensambla los resultados exitosos en un √∫nico objeto JSON
 * @param {Array<Object>} successfulResults - Array de resultados exitosos
 * @returns {Object} - Objeto JSON final ensamblado
 */
function assembleResults(successfulResults) {
  if (successfulResults.length === 0) {
    console.log(`‚ÑπÔ∏è  No hay resultados exitosos para ensamblar.`);
    return {};
  }

  console.log(`üîß Ensamblando ${successfulResults.length} lotes exitosos...`);

  const finalResult = {};

  // Ordenar por batchId para mantener el orden original
  successfulResults.sort(
    (/**@type {any} */ a, /**@type {any} */ b) => a.batchId - b.batchId
  );

  successfulResults.forEach((/**@type {any} */ result) => {
    Object.assign(finalResult, result.data);
  });

  const totalEntries = Object.keys(finalResult).length;
  console.log(
    `‚úÖ Resultado final ensamblado: ${totalEntries} entradas traducidas`
  );

  return finalResult;
}

/**
 * Combina las traducciones nuevas con las entradas ya traducidas y excluidas manteniendo el orden original
 * @param {Object} newTranslations - Nuevas traducciones
 * @param {Object} alreadyTranslated - Entradas que ya estaban traducidas
 * @param {Object} excludedByKey - Entradas excluidas por patr√≥n de clave
 * @param {Array<string>} originalKeys - Orden original de las claves
 * @returns {any} - Resultado final combinado en orden original
 */
function combineResults(
  newTranslations,
  alreadyTranslated,
  excludedByKey,
  originalKeys
) {
  console.log(`üîó Combinando resultados finales manteniendo orden original...`);

  // Crear objeto resultado manteniendo el orden original
  /**@type {any} */
  const combinedResult = {};
  /**@type {any} */
  const allTranslations = {
    ...excludedByKey, // Primero las excluidas (conservan valor original)
    ...alreadyTranslated, // Luego las ya traducidas
    ...newTranslations, // Finalmente las nuevas traducciones
  };

  // Reconstruir el objeto en el orden original
  originalKeys.forEach((key) => {
    if (allTranslations.hasOwnProperty(key)) {
      combinedResult[key] = allTranslations[key];
    }
  });

  const stats = {
    excludedByKey: Object.keys(excludedByKey).length,
    alreadyTranslated: Object.keys(alreadyTranslated).length,
    newTranslations: Object.keys(newTranslations).length,
    total: Object.keys(combinedResult).length,
  };

  console.log(`üìä Combinaci√≥n completada:`);
  console.log(`   üö´ Excluidas por patr√≥n: ${stats.excludedByKey}`);
  console.log(`   ‚úÖ Ya traducidas: ${stats.alreadyTranslated}`);
  console.log(`   üÜï Nuevas traducciones: ${stats.newTranslations}`);
  console.log(`   üìù Total en resultado final: ${stats.total}`);
  console.log(`   üîÑ Orden original preservado: ${originalKeys.length} claves`);

  return { result: combinedResult, stats };
}

/**
 * Genera un reporte detallado del procesamiento
 * @param {any} processingResults - Resultados del procesamiento
 * @param {number} totalBatches - N√∫mero total de lotes
 * @param {any} filterStats - Estad√≠sticas del filtrado
 * @param {any} combineStats - Estad√≠sticas de la combinaci√≥n
 * @param {number} startTime - Timestamp de inicio
 * @returns {any} - Reporte detallado
 */
function generateReport(
  processingResults,
  totalBatches,
  filterStats,
  combineStats,
  startTime
) {
  const endTime = Date.now();
  const duration = endTime - startTime;

  const { successful, failed, stoppedEarly, fatalError } = processingResults;

  const successfulEntries = successful.reduce(
    (/**@type {any} */ sum, /**@type {any} */ result) =>
      sum + Object.keys(result.data).length,
    0
  );

  const report = {
    summary: {
      totalOriginalEntries: filterStats.total,
      entriesAlreadyTranslated: filterStats.alreadyTranslated,
      entriesNeedingTranslation: filterStats.needsTranslation,
      totalBatches,
      successfulBatches: successful.length,
      failedBatches: failed.length,
      successfulNewTranslations: successfulEntries,
      failedTranslations: filterStats.needsTranslation - successfulEntries,
      finalResultEntries: combineStats.total,
      stoppedEarly: stoppedEarly || false,
      fatalError: fatalError || null,
      batchSuccessRate:
        totalBatches > 0
          ? ((successful.length / totalBatches) * 100).toFixed(2) + "%"
          : "N/A",
      translationSuccessRate:
        filterStats.needsTranslation > 0
          ? ((successfulEntries / filterStats.needsTranslation) * 100).toFixed(
              2
            ) + "%"
          : "N/A",
      overallCompletionRate:
        ((combineStats.total / filterStats.total) * 100).toFixed(2) + "%",
      // Campos adicionales para compatibilidad con showFinalStats
      successRate:
        totalBatches > 0
          ? ((successful.length / totalBatches) * 100).toFixed(2) + "%"
          : "N/A",
      totalEntries: filterStats.total,
      successfulEntries: combineStats.total,
      failedEntries: filterStats.total - combineStats.total,
      entriesSuccessRate:
        filterStats.total > 0
          ? ((combineStats.total / filterStats.total) * 100).toFixed(2)
          : "0",
      durationMs: duration,
      durationFormatted: formatDuration(duration),
    },
    filtering: filterStats,
    processing: {
      successful: successful.map((/**@type {any} */ s) => ({
        batchId: s.batchId,
        entriesCount: Object.keys(s.data).length,
        attempts: s.attempts,
      })),
      failed: failed.map((/**@type {any} */ f) => ({
        batchId: f.batchId,
        error: f.error,
        attempts: f.attempts,
        skipped: f.skipped || false,
      })),
    },
    combining: combineStats,
  };

  return report;
}

/**
 * Formatea duraci√≥n en milisegundos a una representaci√≥n legible
 * @param {number} ms - Duraci√≥n en milisegundos
 * @returns {string} - Duraci√≥n formateada
 */
function formatDuration(ms) {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);

  if (hours > 0) {
    return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
  } else if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  } else {
    return `${seconds}s`;
  }
}

/**
 * Realiza un an√°lisis de prueba (dry run) del filtrado sin hacer llamadas a la API
 * @param {string} inputFile - Ruta al archivo JSON de entrada
 * @param {any} config - Configuraci√≥n personalizada (opcional)
 * @returns {Promise<any>} - An√°lisis detallado del filtrado
 */
async function dryRunAnalysis(inputFile, config = {}) {
  const finalConfig = { ...DEFAULT_CONFIG, ...config };

  try {
    console.log("üß™ === AN√ÅLISIS DE FILTRADO (DRY RUN) ===");
    console.log(`üìÅ Archivo de entrada: ${inputFile}`);
    console.log(`‚öôÔ∏è  Configuraci√≥n de filtrado:`);
    console.log(
      `   üîç Filtrado de claves habilitado: ${finalConfig.enableKeyFiltering}`
    );
    console.log(`   ‚è≠Ô∏è  Omitir ya traducidas: ${finalConfig.skipTranslated}`);
    console.log(`   üì¶ Tama√±o de lote configurado: ${finalConfig.batchSize}\n`);

    // 1. Leer archivo de entrada
    const inputData = await readJsonFile(inputFile);

    // 2. Mostrar informaci√≥n del archivo
    const fileInfo = await getFileInfo(inputFile);
    console.log(
      `üìä Informaci√≥n del archivo: ${fileInfo.entriesCount} entradas, ${fileInfo.sizeFormatted}`
    );

    // 3. Realizar filtrado (mismo proceso que en producci√≥n)
    const {
      toTranslate,
      alreadyTranslated,
      excludedByKey,
      originalKeys,
      stats,
    } = filterEntriesForTranslation(
      inputData,
      finalConfig.skipTranslated,
      finalConfig.enableKeyFiltering
    );

    // 4. Analizar patrones de exclusi√≥n
    const exclusionPatterns = analyzeExclusionPatterns(excludedByKey);

    // 5. Crear lotes hipot√©ticos
    const batches = createBatches(toTranslate, finalConfig.batchSize);

    // 6. Generar an√°lisis detallado
    const analysis = {
      fileInfo: {
        path: inputFile,
        totalEntries: stats.total,
        fileSizeFormatted: fileInfo.sizeFormatted,
      },
      filtering: {
        ...stats,
        efficiencyPercentage: (
          ((stats.excludedByKey + stats.alreadyTranslated) / stats.total) *
          100
        ).toFixed(1),
      },
      batching: {
        totalBatches: batches.length,
        batchSize: finalConfig.batchSize,
        entriesPerBatch: batches.map((b) => b.entriesCount),
      },
      exclusionPatterns,
      samples: {
        toTranslate: Object.keys(toTranslate).slice(0, 10),
        alreadyTranslated: Object.keys(alreadyTranslated).slice(0, 10),
        excludedByKey: Object.keys(excludedByKey).slice(0, 20),
      },
      estimatedApiCalls: batches.length,
      estimatedCostSavings: {
        entriesSkipped: stats.excludedByKey + stats.alreadyTranslated,
        batchesSaved: Math.ceil(
          (stats.excludedByKey + stats.alreadyTranslated) /
            finalConfig.batchSize
        ),
      },
    };

    // 7. Mostrar resultados
    displayDryRunResults(analysis);

    return analysis;
  } catch (/**@type {any} */ error) {
    console.error("üíÄ Error durante el an√°lisis de filtrado:", error.message);
    throw error;
  }
}

/**
 * Analiza los patrones de exclusi√≥n para mostrar estad√≠sticas detalladas
 * @param {any} excludedByKey - Claves excluidas por patr√≥n
 * @returns {any} - An√°lisis de patrones
 */
function analyzeExclusionPatterns(excludedByKey) {
  /**@type {any} */
  const patterns = {
    pureNumbers: [], // Solo n√∫meros
    numbersWithUnits: [], // N√∫meros con kg, lb, PCT, etc.
    seasonYears: [], // 1998/99, 2023/24
    spanishText: [], // Texto con acentos o √±
    prefixPatterns: [], // YTD_, _Daily, etc.
    dateAbbreviations: [], // Aug'24, Jan'25
    countryCodes: [], // USA, MEX, CAN
    mexicanCompanies: [], // S.A. de C.V.
    tifCodes: [], // TIF relacionados
    financialCodes: [], // FRED, GDP, USD
    futuresCodes: [], // Daily - Nearby-H
    other: [], // Otros patrones
  };

  Object.keys(excludedByKey).forEach((key) => {
    if (/^\d+$/.test(key)) {
      patterns.pureNumbers.push(key);
    } else if (/\d+.*[-\/><].*\d*|\d+.*\s*(kg|lb|PCT|%|\+)\s*$/i.test(key)) {
      patterns.numbersWithUnits.push(key);
    } else if (/^\d{4}\/\d{2}$/.test(key)) {
      patterns.seasonYears.push(key);
    } else if (/[√°√©√≠√≥√∫√Å√â√ç√ì√ö√±√ë]/.test(key)) {
      patterns.spanishText.push(key);
    } else if (/^(_Daily - |YTD_|DC_.*_YTD|.*_YTD_)/i.test(key)) {
      patterns.prefixPatterns.push(key);
    } else if (
      /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)['']?\d{2}$/.test(key)
    ) {
      patterns.dateAbbreviations.push(key);
    } else if (/^[A-Z]{2,3}$/.test(key)) {
      patterns.countryCodes.push(key);
    } else if (
      /(S\.?\s*A\.?|de\s+C\.?\s*V\.?|A\.?\s*R\.?\s*I\.?\s*C)/i.test(key)
    ) {
      patterns.mexicanCompanies.push(key);
    } else if (/TIF\s*\d+/i.test(key)) {
      patterns.tifCodes.push(key);
    } else if (/^(FRED|FHFA|CPI|PPI|GDP|USD|CAD|EUR|GBP|JPY)$/i.test(key)) {
      patterns.financialCodes.push(key);
    } else if (
      /(Futures?|Daily|Weekly|Monthly|Quarterly).*-\s*(Nearby|H)$/i.test(key)
    ) {
      patterns.futuresCodes.push(key);
    } else {
      patterns.other.push(key);
    }
  });

  // Calcular estad√≠sticas por patr√≥n
  /**@type {any} */
  const stats = {};
  Object.entries(patterns).forEach(([pattern, keys]) => {
    stats[pattern] = {
      count: keys.length,
      samples: keys.slice(0, 5), // Primeros 5 ejemplos
      percentage: (
        (keys.length / Object.keys(excludedByKey).length) *
        100
      ).toFixed(1),
    };
  });

  return { patterns, stats };
}

/**
 * Muestra los resultados del an√°lisis de filtrado de manera organizada
 * @param {any} analysis - An√°lisis completo
 */
function displayDryRunResults(analysis) {
  console.log("\nüìã === RESULTADOS DEL AN√ÅLISIS ===");

  // Resumen general
  console.log("üìä RESUMEN GENERAL:");
  console.log(`   üìù Total de entradas: ${analysis.fileInfo.totalEntries}`);
  console.log(
    `   üîÑ Necesitan traducci√≥n: ${analysis.filtering.needsTranslation}`
  );
  console.log(`   ‚úÖ Ya traducidas: ${analysis.filtering.alreadyTranslated}`);
  console.log(
    `   üö´ Excluidas por patr√≥n: ${analysis.filtering.excludedByKey}`
  );
  console.log(
    `   üìà Eficiencia de filtrado: ${analysis.filtering.efficiencyPercentage}%`
  );

  // Informaci√≥n de lotes
  console.log("\nüì¶ INFORMACI√ìN DE LOTES:");
  console.log(
    `   üî¢ Total de lotes a procesar: ${analysis.batching.totalBatches}`
  );
  console.log(`   üìè Tama√±o de lote: ${analysis.batching.batchSize}`);
  if (analysis.batching.totalBatches > 0) {
    console.log(
      `   üìä Distribuci√≥n: ${analysis.batching.entriesPerBatch.join(
        ", "
      )} entradas por lote`
    );
  }

  // Patrones de exclusi√≥n m√°s comunes
  console.log("\nüîç TOP PATRONES DE EXCLUSI√ìN:");
  const topPatterns = Object.entries(analysis.exclusionPatterns.stats)
    .filter(([_, data]) => data.count > 0)
    .sort((a, b) => b[1].count - a[1].count)
    .slice(0, 8);

  topPatterns.forEach(([pattern, data]) => {
    /**@type {any} */
    const patternNames = {
      pureNumbers: "N√∫meros puros",
      numbersWithUnits: "N√∫meros con unidades",
      seasonYears: "A√±os de temporada",
      spanishText: "Texto en espa√±ol",
      prefixPatterns: "Prefijos espec√≠ficos",
      dateAbbreviations: "Fechas abreviadas",
      countryCodes: "C√≥digos de pa√≠s",
      mexicanCompanies: "Empresas mexicanas",
      tifCodes: "C√≥digos TIF",
      financialCodes: "C√≥digos financieros",
      futuresCodes: "C√≥digos de futuros",
    };

    console.log(
      `   ${patternNames[pattern] || pattern}: ${data.count} (${
        data.percentage
      }%)`
    );
    if (data.samples.length > 0) {
      console.log(
        `     Ejemplos: ${data.samples.slice(0, 3).join(", ")}${
          data.samples.length > 3 ? "..." : ""
        }`
      );
    }
  });

  // Muestras de lo que se procesar√≠a
  console.log("\nüìù MUESTRAS DE CLAVES A TRADUCIR:");
  if (analysis.samples.toTranslate.length > 0) {
    analysis.samples.toTranslate.forEach(
      (/**@type {any} */ key, /**@type {number} */ index) => {
        console.log(`   ${index + 1}. "${key}"`);
      }
    );
    if (analysis.filtering.needsTranslation > 10) {
      console.log(`   ... y ${analysis.filtering.needsTranslation - 10} m√°s`);
    }
  } else {
    console.log("   ‚ÑπÔ∏è  No hay claves que necesiten traducci√≥n");
  }

  // Estimaci√≥n de costos
  console.log("\nüí∞ ESTIMACI√ìN DE EFICIENCIA:");
  console.log(`   üìû Llamadas API estimadas: ${analysis.estimatedApiCalls}`);
  console.log(
    `   üíæ Entradas omitidas: ${analysis.estimatedCostSavings.entriesSkipped}`
  );
  console.log(
    `   üì¶ Lotes ahorrados: ~${analysis.estimatedCostSavings.batchesSaved}`
  );

  if (analysis.estimatedApiCalls === 0) {
    console.log("\nüéâ ¬°Excelente! No se necesitan llamadas a la API.");
    console.log(
      "   ‚úÖ Todas las entradas ya est√°n traducidas o fueron filtradas."
    );
  } else {
    const savings = (
      (analysis.estimatedCostSavings.entriesSkipped /
        analysis.fileInfo.totalEntries) *
      100
    ).toFixed(1);
    console.log(
      `\nüìà Ahorro estimado: ${savings}% de las entradas no requieren procesamiento`
    );
  }

  console.log("\nüß™ === FIN DEL AN√ÅLISIS ===");
}

/**
 * Funci√≥n principal que orquesta todo el proceso de traducci√≥n por lotes
 * @param {string} inputFile - Ruta al archivo JSON de entrada
 * @param {Object} config - Configuraci√≥n personalizada (opcional)
 * @returns {Promise<Object>} - Reporte final del procesamiento
 */
async function processTranslation(inputFile, config = {}) {
  const startTime = Date.now();
  const finalConfig = { ...DEFAULT_CONFIG, ...config };

  try {
    console.log("üéØ === INICIO DEL PROCESAMIENTO DE TRADUCCI√ìN ===");
    console.log(`üìÅ Archivo de entrada: ${inputFile}`);
    console.log(`üìÅ Archivo de salida: ${finalConfig.outputFile}`);
    console.log(`‚öôÔ∏è  Configuraci√≥n:`, finalConfig);

    // 0. Inicializar rate limiter si est√° habilitado
    if (finalConfig.respectRateLimits) {
      console.log(`üö¶ Inicializando control de l√≠mites de velocidad...`);
      await initializeRateLimiter(
        finalConfig.tier,
        finalConfig.model,
        finalConfig.rateLimitsFile
      );
    } else {
      console.log(`‚ö†Ô∏è  Control de l√≠mites de velocidad deshabilitado`);
    }

    // 1. Leer archivo de entrada
    /**@type {any} */
    const inputData = await readJsonFile(inputFile);

    // 2. Mostrar informaci√≥n del archivo
    /**@type {any} */
    const fileInfo = await getFileInfo(inputFile);
    console.log(
      `üìä Informaci√≥n del archivo: ${fileInfo.entriesCount} entradas, ${fileInfo.sizeFormatted}`
    );

    // 3. Filtrar entradas que necesitan traducci√≥n
    const {
      toTranslate,
      alreadyTranslated,
      excludedByKey,
      originalKeys,
      stats: filterStats,
    } = filterEntriesForTranslation(
      inputData,
      finalConfig.skipTranslated,
      finalConfig.enableKeyFiltering
    );

    // 4. Crear lotes solo con las entradas que necesitan traducci√≥n
    const batches = createBatches(toTranslate, finalConfig.batchSize);

    // 5. Procesar lotes concurrentemente (solo si hay lotes)
    const processingResults = await processBatchesConcurrently(
      batches,
      finalConfig
    );

    // 6. Ensamblar resultados exitosos
    const newTranslations = assembleResults(processingResults.successful);

    // 7. Combinar nuevas traducciones con las ya existentes y excluidas manteniendo orden original
    const { result: finalResult, stats: combineStats } = combineResults(
      newTranslations,
      alreadyTranslated,
      excludedByKey,
      originalKeys
    );

    // 8. Manejar guardado seg√∫n si se detuvo por error fatal o no
    if (processingResults.stoppedEarly) {
      // Guardar traducciones parciales con sufijo especial
      const partialOutputFile = finalConfig.outputFile.replace(
        /(\.json)$/,
        "_partial$1"
      );

      console.log(
        `‚ö†Ô∏è  Procesamiento detenido por error fatal: ${processingResults.fatalError}`
      );
      console.log(
        `üíæ Guardando traducciones parciales en: ${partialOutputFile}`
      );

      if (Object.keys(finalResult).length > 0) {
        await writeJsonFile(partialOutputFile, finalResult);
        console.log(
          `‚úÖ Traducciones parciales guardadas exitosamente (${
            Object.keys(finalResult).length
          } entradas)`
        );
      } else {
        console.log(`‚ö†Ô∏è  No hay traducciones parciales para guardar.`);
      }
    } else {
      // Guardado normal
      if (Object.keys(finalResult).length > 0) {
        await writeJsonFile(finalConfig.outputFile, finalResult);
      } else {
        console.log(`‚ö†Ô∏è  No hay datos para guardar en el archivo de salida.`);
      }
    }

    // 9. Generar reporte
    const report = generateReport(
      processingResults,
      batches.length,
      filterStats,
      combineStats,
      startTime
    );

    // 10. Mostrar resumen
    console.log("\nüìã === RESUMEN DEL PROCESAMIENTO ===");

    if (processingResults.stoppedEarly) {
      console.log(
        `üõë PROCESAMIENTO DETENIDO POR ERROR FATAL: ${processingResults.fatalError}`
      );
      console.log(
        `ÔøΩ Traducciones parciales guardadas en archivo con sufijo '_partial'`
      );
      console.log(`üìä Progreso alcanzado antes del error:`);
    }

    console.log(
      `ÔøΩüìù Entradas originales: ${report.summary.totalOriginalEntries}`
    );
    console.log(
      `‚úÖ Ya traducidas (omitidas): ${report.summary.entriesAlreadyTranslated}`
    );
    console.log(
      `üîÑ Necesitaban traducci√≥n: ${report.summary.entriesNeedingTranslation}`
    );
    console.log(
      `‚úÖ Nuevas traducciones exitosas: ${report.summary.successfulNewTranslations}`
    );
    console.log(
      `‚ùå Traducciones fallidas: ${report.summary.failedTranslations}`
    );
    console.log(
      `üìÑ Total en archivo final: ${report.summary.finalResultEntries}`
    );
    console.log(
      `üìà Tasa de √©xito en traducci√≥n: ${report.summary.translationSuccessRate}`
    );
    console.log(
      `üìà Completitud total: ${report.summary.overallCompletionRate}`
    );
    console.log(`‚è±Ô∏è  Duraci√≥n total: ${report.summary.durationFormatted}`);

    if (report.summary.failedBatches > 0) {
      console.log("\n‚ùå LOTES FALLIDOS:");
      report.processing.failed.forEach((/**@type {any} */ f) => {
        if (f.skipped) {
          console.log(`   Lote ${f.batchId}: ${f.error} (omitido)`);
        } else {
          console.log(`   Lote ${f.batchId}: ${f.error}`);
        }
      });
    }

    console.log("üéØ === FIN DEL PROCESAMIENTO ===\n");

    return report;
  } catch (/**@type {any} */ error) {
    console.error("üíÄ Error cr√≠tico durante el procesamiento:", error.message);
    throw error;
  }
}

module.exports = {
  processTranslation,
  dryRunAnalysis,
  filterEntriesForTranslation,
  needsTranslation,
  shouldExcludeKey,
  createBatches,
  processBatchWithRetry,
  processBatchesConcurrently,
  assembleResults,
  combineResults,
  generateReport,
  // Rate limiting functions
  initializeRateLimiter,
  loadRateLimits,
  canMakeRequest,
  recordRequest,
  waitForRateLimit,
  getRateLimiterStatus,
  DEFAULT_CONFIG,
};
