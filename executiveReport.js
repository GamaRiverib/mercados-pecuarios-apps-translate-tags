#!/usr/bin/env node

// @ts-check

const fs = require("fs").promises;
const path = require("path");
const { readJsonFile, getFileInfo } = require("./fileHandler");
const { dryRunAnalysis } = require("./batchProcessor");

/**
 * Configuraci√≥n por defecto para el informe ejecutivo
 */
const REPORT_CONFIG = {
  inputFile: "us-mx.json", // Archivo a analizar por defecto
  outputFile: null, // Se genera autom√°ticamente si no se especifica
  includeDetailedPatterns: true, // Incluir patrones detallados
  includeRecommendations: true, // Incluir recomendaciones
  includeSamples: true, // Incluir muestras de claves
  maxSamples: 15, // N√∫mero m√°ximo de muestras por categor√≠a
  tier: "free_tier", // Tier por defecto
  model: "gemini-2.0-flash-lite", // Modelo por defecto
  enableKeyFiltering: true, // Habilitar filtrado por defecto
};

/**
 * Parsea argumentos de l√≠nea de comandos para el informe
 * @returns {any} - Argumentos parseados
 */
function parseCommandLineArgs() {
  const args = process.argv.slice(2);
  /**@type {any} */
  const parsed = { ...REPORT_CONFIG };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    if (arg === "--help" || arg === "-h") {
      showHelp();
      process.exit(0);
    } else if (arg === "--input" || arg === "-i") {
      parsed.inputFile = args[++i];
    } else if (arg === "--output" || arg === "-o") {
      parsed.outputFile = args[++i];
    } else if (arg === "--tier") {
      parsed.tier = args[++i];
    } else if (arg === "--model") {
      parsed.model = args[++i];
    } else if (arg === "--no-filter") {
      parsed.enableKeyFiltering = false;
    } else if (arg === "--no-patterns") {
      parsed.includeDetailedPatterns = false;
    } else if (arg === "--no-recommendations") {
      parsed.includeRecommendations = false;
    } else if (arg === "--no-samples") {
      parsed.includeSamples = false;
    } else if (arg === "--max-samples") {
      parsed.maxSamples = parseInt(args[++i]) || 15;
    } else if (!arg.startsWith("--")) {
      // Si no es un flag, asumimos que es el archivo de entrada
      parsed.inputFile = arg;
    }
  }

  return parsed;
}

/**
 * Muestra la ayuda del comando
 */
function showHelp() {
  console.log("üìä === GENERADOR DE INFORME EJECUTIVO ===");
  console.log(
    "üìù Genera un informe detallado en Markdown del an√°lisis de filtrado\n"
  );

  console.log("üíæ USO:");
  console.log("  node executiveReport.js [archivo.json] [opciones]\n");

  console.log("üîß OPCIONES:");
  console.log("  --input, -i <archivo>     Archivo JSON de entrada");
  console.log("  --output, -o <archivo>    Archivo Markdown de salida");
  console.log(
    "  --tier <tier>             Tier de la API (free_tier, tier_1, etc.)"
  );
  console.log("  --model <modelo>          Modelo de Gemini a usar");
  console.log("  --no-filter               Simular sin filtrado de claves");
  console.log("  --no-patterns             No incluir patrones detallados");
  console.log("  --no-recommendations      No incluir recomendaciones");
  console.log("  --no-samples              No incluir muestras de claves");
  console.log(
    "  --max-samples <n√∫mero>    M√°ximo n√∫mero de muestras (por defecto: 15)"
  );
  console.log("  --help, -h                Mostrar esta ayuda\n");

  console.log("üìã EJEMPLOS:");
  console.log("  # Informe b√°sico");
  console.log("  node executiveReport.js us-mx.json");
  console.log("");
  console.log("  # Informe personalizado");
  console.log(
    "  node executiveReport.js --input data.json --output analysis.md"
  );
  console.log("");
  console.log("  # Sin filtrado para ver todas las claves");
  console.log("  node executiveReport.js data.json --no-filter");
  console.log("");
  console.log("  # Informe compacto sin muestras");
  console.log("  node executiveReport.js data.json --no-samples --no-patterns");
  console.log("");
  console.log("  # Para tier espec√≠fico");
  console.log(
    "  node executiveReport.js data.json --tier tier_1 --model gemini-2.0-flash-lite"
  );
  console.log("");
}

/**
 * Genera el nombre del archivo de salida autom√°ticamente
 * @param {string} inputFile - Archivo de entrada
 * @returns {string} - Nombre del archivo de salida
 */
function generateOutputFileName(inputFile) {
  const parsed = path.parse(inputFile);
  const timestamp = new Date()
    .toISOString()
    .replace(/[:.]/g, "-")
    .split("T")[0];
  return path.join(
    parsed.dir,
    `${parsed.name}_executive_report_${timestamp}.md`
  );
}

/**
 * Formatea un n√∫mero con separadores de miles
 * @param {number} num - N√∫mero a formatear
 * @returns {string} - N√∫mero formateado
 */
function formatNumber(num) {
  return num.toLocaleString("es-ES");
}

/**
 * Genera el contenido del informe ejecutivo en Markdown
 * @param {any} analysis - An√°lisis completo del dry run
 * @param {any} config - Configuraci√≥n usada
 * @returns {string} - Contenido del informe en Markdown
 */
function generateExecutiveReport(analysis, config) {
  const timestamp = new Date().toLocaleString("es-ES", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });

  let markdown = `# üìä Informe Ejecutivo de An√°lisis de Traducci√≥n

## üìã Informaci√≥n General

- **Archivo analizado:** \`${analysis.fileInfo.path}\`
- **Fecha del an√°lisis:** ${timestamp}
- **Configuraci√≥n de filtrado:** ${
    config.enableKeyFiltering ? "Habilitado" : "Deshabilitado"
  }
- **Tier de API:** ${config.tier}
- **Modelo:** ${config.model}
- **Tama√±o del archivo:** ${analysis.fileInfo.fileSizeFormatted}

## üìà Resumen Ejecutivo

`;

  // Agregar resumen ejecutivo
  const { filtering, batching, estimatedApiCalls } = analysis;

  if (estimatedApiCalls === 0) {
    markdown += `> ‚úÖ **RESULTADO √ìPTIMO:** No se requieren llamadas a la API de traducci√≥n.
> Todas las entradas est√°n ya traducidas o fueron excluidas por el filtrado inteligente.

`;
  } else {
    markdown += `> üéØ **AN√ÅLISIS COMPLETADO:** De ${formatNumber(
      filtering.total
    )} entradas totales, 
> ${formatNumber(filtering.needsTranslation)} requieren traducci√≥n (${(
      (filtering.needsTranslation / filtering.total) *
      100
    ).toFixed(1)}% del total).
> El sistema procesar√° ${formatNumber(
      estimatedApiCalls
    )} llamadas API en ${formatNumber(batching.totalBatches)} lotes.

`;
  }

  // Estad√≠sticas principales
  markdown += `## üìä Estad√≠sticas Principales

| M√©trica | Cantidad | Porcentaje |
|---------|----------|------------|
| **Total de entradas** | ${formatNumber(filtering.total)} | 100.0% |
| **Necesitan traducci√≥n** | ${formatNumber(filtering.needsTranslation)} | ${(
    (filtering.needsTranslation / filtering.total) *
    100
  ).toFixed(1)}% |
| **Ya traducidas** | ${formatNumber(filtering.alreadyTranslated)} | ${(
    (filtering.alreadyTranslated / filtering.total) *
    100
  ).toFixed(1)}% |
| **Excluidas por patr√≥n** | ${formatNumber(filtering.excludedByKey)} | ${(
    (filtering.excludedByKey / filtering.total) *
    100
  ).toFixed(1)}% |
| **Eficiencia de filtrado** | - | ${filtering.efficiencyPercentage}% |

`;

  // Informaci√≥n de procesamiento
  if (estimatedApiCalls > 0) {
    markdown += `## üîÑ Informaci√≥n de Procesamiento

- **Llamadas API estimadas:** ${formatNumber(estimatedApiCalls)}
- **Lotes a procesar:** ${formatNumber(batching.totalBatches)}
- **Tama√±o de lote:** ${formatNumber(batching.batchSize)} entradas
- **Distribuci√≥n por lote:** ${batching.entriesPerBatch.join(", ")} entradas
- **Entradas omitidas:** ${formatNumber(
      analysis.estimatedCostSavings.entriesSkipped
    )}

`;
  }

  // Top patrones de exclusi√≥n
  if (config.includeDetailedPatterns && filtering.excludedByKey > 0) {
    markdown += `## üîç Top Patrones de Exclusi√≥n

Los siguientes patrones fueron identificados y excluidos autom√°ticamente:

`;

    const topPatterns = Object.entries(analysis.exclusionPatterns.stats)
      .filter(([_, data]) => data.count > 0)
      .sort((a, b) => b[1].count - a[1].count)
      .slice(0, 8);

    /**
     * @type {{[key: string]: string}}
     */
    const patternNames = {
      pureNumbers: "N√∫meros puros",
      numbersWithUnits: "N√∫meros con unidades",
      seasonYears: "A√±os de temporada",
      spanishText: "Texto en espa√±ol",
      prefixPatterns: "Prefijos espec√≠ficos",
      dateAbbreviations: "Fechas abreviadas",
      countryCodes: "C√≥digos de pa√≠s",
      mexicanCompanies: "Empresas mexicanas",
      tifCodes: "C√≥digos TIF",
      financialCodes: "C√≥digos financieros",
      futuresCodes: "C√≥digos de futuros",
      other: "Otros patrones",
    };

    markdown += `| Patr√≥n | Cantidad | Porcentaje | Ejemplos |\n`;
    markdown += `|--------|----------|------------|----------|\n`;

    topPatterns.forEach(([pattern, data]) => {
      const patternName = patternNames[pattern] || pattern;
      const examples = data.samples
        .slice(0, 3)
        .map((/** @type {string} */ s) => `\`${s}\``)
        .join(", ");
      markdown += `| ${patternName} | ${formatNumber(data.count)} | ${
        data.percentage
      }% | ${examples} |\n`;
    });

    markdown += `\n`;
  }

  // Muestras de claves a traducir
  if (config.includeSamples && analysis.samples.toTranslate.length > 0) {
    markdown += `## üìù Muestras de Claves a Traducir

Las siguientes claves requieren traducci√≥n:

`;
    const samplesToShow = analysis.samples.toTranslate.slice(
      0,
      config.maxSamples
    );
    samplesToShow.forEach(
      (/** @type {string} */ key, /** @type {number} */ index) => {
        markdown += `${index + 1}. \`"${key}"\`\n`;
      }
    );

    if (filtering.needsTranslation > samplesToShow.length) {
      markdown += `\n*... y ${formatNumber(
        filtering.needsTranslation - samplesToShow.length
      )} m√°s*\n`;
    }

    markdown += `\n`;
  }

  // Recomendaciones
  if (config.includeRecommendations) {
    markdown += `## üí° Recomendaciones

`;

    if (estimatedApiCalls === 0) {
      markdown += `### ‚úÖ Estado √ìptimo
- **Acci√≥n requerida:** Ninguna
- **Motivo:** Todas las entradas est√°n ya procesadas o excluidas
- **Siguiente paso:** El archivo est√° listo para uso

`;
    } else if (estimatedApiCalls <= 10) {
      markdown += `### üöÄ Procesamiento Directo Recomendado
- **Archivo peque√±o:** Procesar directamente con \`npm run poc\`
- **Tiempo estimado:** Menos de 5 minutos
- **Costo:** M√≠nimo (${estimatedApiCalls} llamadas API)

`;
    } else if (estimatedApiCalls <= 50) {
      markdown += `### ‚öôÔ∏è Procesamiento por Lotes Est√°ndar
- **Archivo mediano:** Usar configuraci√≥n por defecto
- **Comando:** \`npm run start\`
- **Tiempo estimado:** 10-20 minutos
- **Monitoreo:** Revisar progreso cada 5 minutos

`;
    } else {
      markdown += `### üéØ Procesamiento por Lotes Optimizado
- **Archivo grande:** Considerar configuraci√≥n avanzada
- **Tier recomendado:** tier_1 o superior para mejor rendimiento
- **Comando:** \`npm run start -- --tier tier_1\`
- **Tiempo estimado:** 30+ minutos
- **Estrategia:** Procesar en m√∫ltiples sesiones si es necesario

`;
    }

    markdown += `### üîß Optimizaciones Sugeridas

`;

    if (filtering.efficiencyPercentage < 20) {
      markdown += `- **Filtrado:** Eficiencia baja (${filtering.efficiencyPercentage}%). Considerar agregar m√°s patrones de exclusi√≥n.
`;
    }

    if (batching.totalBatches > 100) {
      markdown += `- **Lotes:** ${batching.totalBatches} lotes es alto. Considerar aumentar tama√±o de lote para eficiencia.
`;
    }

    if (filtering.excludedByKey > filtering.needsTranslation) {
      markdown += `- **Filtrado efectivo:** M√°s entradas excluidas que a traducir. Excelente optimizaci√≥n.
`;
    }

    markdown += `\n### üìã Pr√≥ximos Pasos

1. **Validar configuraci√≥n:** \`npm run validate\`
2. **Probar conexi√≥n:** \`npm run test-connection\`
3. **Ejecutar traducci√≥n:** \`npm run start\`
4. **Monitorear progreso:** Revisar logs durante el proceso
5. **Validar resultados:** Verificar archivo de salida

`;
  }

  // Informaci√≥n t√©cnica
  markdown += `## üîß Informaci√≥n T√©cnica

### Configuraci√≥n de An√°lisis
- **Filtrado de claves:** ${
    config.enableKeyFiltering ? "Habilitado" : "Deshabilitado"
  }
- **Omitir ya traducidas:** Habilitado
- **Tama√±o de lote:** ${batching.batchSize} entradas
- **L√≠mites de API:** Seg√∫n tier ${config.tier}

### Patrones de Filtrado Aplicados
`;

  if (config.enableKeyFiltering) {
    markdown += `- ‚úÖ N√∫meros puros (a√±os, c√≥digos)
- ‚úÖ N√∫meros con unidades (kg, lb, PCT)
- ‚úÖ A√±os de temporada (1998/99, 2023/24)
- ‚úÖ Texto ya en espa√±ol (acentos, √±)
- ‚úÖ Prefijos espec√≠ficos (YTD_, _Daily)
- ‚úÖ Fechas abreviadas (Aug'24, Jan'25)
- ‚úÖ C√≥digos de pa√≠s (USA, MEX, CAN)
- ‚úÖ Empresas mexicanas (S.A. de C.V.)
- ‚úÖ C√≥digos financieros (FRED, GDP, USD)
- ‚úÖ C√≥digos de futuros y commodities
`;
  } else {
    markdown += `- ‚ö†Ô∏è Filtrado deshabilitado - Se procesar√°n todas las claves
`;
  }

  markdown += `\n---

*Informe generado autom√°ticamente por el Sistema de Traducci√≥n Masiva*  
*Fecha: ${timestamp}*
`;

  return markdown;
}

/**
 * Funci√≥n principal
 */
async function main() {
  try {
    console.log("üìä === GENERADOR DE INFORME EJECUTIVO ===");
    console.log("üìù Generando informe detallado en formato Markdown\n");

    // Parsear argumentos
    const config = parseCommandLineArgs();

    console.log("‚öôÔ∏è Configuraci√≥n:");
    console.log(`   üìÅ Archivo de entrada: ${config.inputFile}`);
    console.log(
      `   üìÅ Archivo de salida: ${config.outputFile || "Auto-generado"}`
    );
    console.log(
      `   üîç Filtrado: ${
        config.enableKeyFiltering ? "Habilitado" : "Deshabilitado"
      }`
    );
    console.log(`   üìä Tier: ${config.tier}`);
    console.log(`   ü§ñ Modelo: ${config.model}`);
    console.log(
      `   üìã Incluir patrones: ${config.includeDetailedPatterns ? "S√≠" : "No"}`
    );
    console.log(
      `   üí° Incluir recomendaciones: ${
        config.includeRecommendations ? "S√≠" : "No"
      }`
    );
    console.log(
      `   üìù Incluir muestras: ${config.includeSamples ? "S√≠" : "No"}`
    );
    console.log("");

    // Verificar que el archivo existe
    try {
      await fs.access(config.inputFile);
      console.log(`‚úÖ Archivo de entrada encontrado: ${config.inputFile}`);
    } catch (error) {
      console.error(`‚ùå Archivo de entrada no encontrado: ${config.inputFile}`);
      console.log("üí° Tip: Verifica que la ruta del archivo sea correcta");
      process.exit(1);
    }

    // Ejecutar an√°lisis dry run
    console.log("\nüîç === EJECUTANDO AN√ÅLISIS ===");
    const analysis = await dryRunAnalysis(config.inputFile, {
      enableKeyFiltering: config.enableKeyFiltering,
      skipTranslated: true,
      batchSize: 15,
      tier: config.tier,
      model: config.model,
    });

    // Generar nombre de archivo de salida si no se especific√≥
    if (!config.outputFile) {
      config.outputFile = generateOutputFileName(config.inputFile);
    }

    // Generar contenido del informe
    console.log("\nüìù === GENERANDO INFORME MARKDOWN ===");
    const reportContent = generateExecutiveReport(analysis, config);

    // Crear directorio de salida si no existe
    const outputDir = path.dirname(config.outputFile);
    await fs.mkdir(outputDir, { recursive: true });

    // Escribir archivo de informe
    await fs.writeFile(config.outputFile, reportContent, "utf-8");

    // Obtener informaci√≥n del archivo generado
    const stats = await fs.stat(config.outputFile);
    const sizeKB = (stats.size / 1024).toFixed(2);

    console.log(`‚úÖ Informe ejecutivo generado: ${config.outputFile}`);
    console.log(`üìä Tama√±o del informe: ${sizeKB} KB`);

    // Mostrar resumen
    console.log("\nüìã === RESUMEN DEL INFORME ===");
    console.log(`üìÅ Archivo analizado: ${config.inputFile}`);
    console.log(`üìÑ Informe generado: ${config.outputFile}`);
    console.log(
      `üìù Entradas totales: ${formatNumber(analysis.fileInfo.totalEntries)}`
    );
    console.log(
      `üîÑ Necesitan traducci√≥n: ${formatNumber(
        analysis.filtering.needsTranslation
      )}`
    );
    console.log(
      `üìû Llamadas API estimadas: ${formatNumber(analysis.estimatedApiCalls)}`
    );
    console.log(
      `üìà Eficiencia de filtrado: ${analysis.filtering.efficiencyPercentage}%`
    );

    console.log("\nüí° PR√ìXIMOS PASOS:");
    if (analysis.estimatedApiCalls === 0) {
      console.log("   ‚úÖ No se requiere traducci√≥n - archivo ya est√° completo");
    } else if (analysis.estimatedApiCalls <= 10) {
      console.log("   üöÄ Archivo peque√±o - ejecutar: npm run poc");
    } else {
      console.log("   ‚öôÔ∏è Archivo grande - ejecutar: npm run start");
    }
    console.log(
      `   üìñ Revisar informe completo: ${path.basename(config.outputFile)}`
    );

    console.log("\nüéâ === INFORME EJECUTIVO COMPLETADO ===");
  } catch (/** @type {any} */ error) {
    console.error("\nüíÄ ERROR CR√çTICO:");
    console.error(`   Mensaje: ${error.message}`);
    if (error.code === "ENOENT") {
      console.log(
        "üí° Tip: Verifica que el archivo de entrada exista y sea accesible"
      );
    }
    process.exit(1);
  }
}

// Ejecutar solo si es llamado directamente
if (require.main === module) {
  main();
}

module.exports = {
  generateExecutiveReport,
  generateOutputFileName,
  parseCommandLineArgs,
  REPORT_CONFIG,
};
